Numbers:     2    3    4     5
Lefts:            2  2*3 2*3*4
Rights:  3*4*5  4*5    5
​
좌측에서 출발하여 해당 인덱스 이전 인덱스들의 곱을 해당 인덱스에 기록하는데
반대로 우측에서 출발할 때도 동일하게 동작하며 이 두 값의 곱이 해당 인덱스를 제외한 곱의 결과이다.
​
---
이 구현 말고 기존 내가 생각하여 해결한 방식도 나쁘지 않아보임
이 방법도 시간복잡도는 2N 이며 오히려 추가적인 공간을 사용하지 않는다.
1. 모든 요소를 돌며 모든 요소를 곱한 값을 구한다.
2. 요소가 0의 경우만 곱하지 않고 카운트를 올린다.
3. 결과적으로 0을 제외한 요소들의 총 곱의 결과(all)와 0 요소를 가진 인덱스의 개수(count)가 나온다.
4. 다시 모든 요소를 도는데
- count > 1   : 모든 요소를 0으로 초기화
- count == 1 : 해당 인덱스 요소가 0인 경우 all로 초기화, 0이 아닌 경우 0으로 초기화
- count == 0 : 모든 요소를 (all / 해당 인덱스 요소) 로 초기화